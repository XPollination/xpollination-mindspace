# PDSA: Mindspace Vision — Mindmap-Based Project Management for Human-Agent Alignment

**PDSA ID:** 2026-02-02-UTC-1300.mindspace-vision
**Project:** xpollination-mindspace
**Status:** PLAN
**Created:** 2026-02-02
**Priority:** CRITICAL — Defines the foundational mental model for all projects
**Agent:** PDSA Agent

---

## MANAGEMENT ABSTRACT

**What:** Define the vision for xpollination-mindspace — a project management system built on the **mindmap** metaphor, where trees of shared thought keep humans and agents in alignment.

**Why:** The PM tool evolved through v1 (flat YAML dashboard), v2 (PDSA visualization), and v3 (recursive task tree with agent assignments). Thomas's insight: these iterations were converging toward something larger — not just a task tracker, but a **shared mental model**. The mindmap IS the alignment. Every node is a thought. Traversing the graph is traversing shared understanding.

**Outcome:** A vision document that:
1. Reframes the v3 recursive tree as a mindmap of shared thought
2. Makes Definition of Ready / Definition of Done intrinsic node properties (object-oriented)
3. Establishes the dual-link pattern for cross-repo navigation
4. Defines graph traversal and node rearrangement requirements
5. Provides a migration plan from xpollination-mcp-server to this repo

---

## PLAN

### 1. The Core Metaphor: Mindmap as Shared Mental Model

Thomas's vision: the PM tool is really a **new approach to project management** — keeping thoughts in alignment between human and agents.

The key reframe:

| PM Tool Concept | Mindmap Concept |
|-----------------|-----------------|
| Task tree | Tree of thoughts |
| Node | A thought (project, idea, task, decision) |
| Children | Deeper decomposition of a thought |
| Root nodes | Top-level projects / mental domains |
| Scope stack | Where attention is focused right now |
| Agent assignment | Who is thinking about / working on this thought |
| Quality gate | Verification that the thought was realized correctly |
| PDSA cycle | The discipline of thinking: Plan the thought → Do it → Study what happened → Act on learnings |

This is not just naming — it changes how the tool is used. A task tracker asks "what's the status?" A mindmap asks "what are we thinking about, and do we understand it the same way?"

### 2. The Trivium Method: How to Think Before What to Build

The mindmap is grounded in the **Trivium Method** — a three-stage process for systematic thinking from the classical Liberal Arts (Latin *trivium*, "the place where three roads meet"):

#### 2.1 The Three Stages

| Stage | Question | Activity |
|-------|----------|----------|
| **1. Grammar** (Knowledge / Input) | Who, what, where, when? | Gather raw facts. Map what you know. Identify the gaps — what you *don't* know. |
| **2. Logic** (Understanding / Processing) | Why? | Analyze what you've gathered. Test for contradictions, eliminate false assumptions, explore unknowns until you have a coherent, verified foundation. |
| **3. Rhetoric** (Wisdom / Output) | How? | Apply that understanding. Make sound projections, communicate a position, determine the right next step. |

**The discipline:** Strict sequence. Don't jump to conclusions or action (Rhetoric) before you've gathered facts (Grammar) and pressure-tested them (Logic). The Trivium teaches HOW to think, not WHAT to think.

#### 2.2 Trivium Maps to the Mindmap and PDSA

The Trivium is not separate from what we already do — it explains WHY the mindmap and PDSA work:

| Trivium Stage | Mindmap Activity | PDSA Phase |
|---------------|-----------------|------------|
| **Grammar** | Build the mindmap — structure all thoughts, gather requirements, map what exists and what's unknown | **Plan** — gather facts, define the problem |
| **Logic** | PDSA cycles within nodes — test each thought, verify assumptions, identify root causes, iterate until the foundation is solid | **Study** — analyze results, test understanding |
| **Rhetoric** | Implementation — only after Grammar and Logic are done, produce the output (code, config, documentation) | **Do** / **Act** — execute with understanding, apply learnings |

#### 2.3 Why This Matters for the Mindmap

This explains why going deep into "rabbit holes" is productive, not wasteful: you're doing Grammar and Logic properly before Rhetoric. The mindmap ensures you can always find your way back because the structure is visible — every thought is a node, every exploration is a sub-tree.

It also explains why premature implementation fails: jumping to Rhetoric (building) without completing Grammar (what are we building?) and Logic (does this design hold up?) produces work that needs to be redone.

The mindmap IS the Grammar phase made visible. PDSA cycles are the Logic phase made systematic. Development is the Rhetoric phase — and it only happens when the thinking is solid.

### 3. The Mindspace Structure: What's Inside the Mindmap

The mindmap's top-level nodes represent the internal structure of xpollination-mindspace itself — the categories of thought needed to build this tool:

```
xpollination-mindspace (root)
├── Requirements                — Questions to think through before building
│   ├── What is a "thought" in the mindmap?
│   ├── How do nodes relate to each other?
│   ├── What does Definition of Ready mean for a node?
│   ├── What does Definition of Done mean for a node?
│   ├── How does the Trivium apply to each node's lifecycle?
│   └── ... (explored via PDSA cycles — go deeper until sufficient)
├── Features                    — What the tool does
│   ├── Graph traversal (navigate the full tree)
│   ├── Drag-and-drop (rearrange thoughts between branches)
│   ├── Dual-link pattern (git URL + local path)
│   ├── PDSA integration (every node can be a PDSA cycle)
│   ├── Agent assignment and color-coding
│   └── ... (each feature gets its own PDSA when ready to build)
└── Infrastructure              — How it's built
    ├── Tech stack (Hugo, Alpine.js, SortableJS, Tailwind)
    ├── Data model (YAML node schema)
    ├── Deployment (Hetzner, nginx)
    └── Migration from xpollination-mcp-server
```

**The process:** Each requirement node gets explored. When you define something clearly enough, you add a PDSA in the right context and link it. You go deeper until it's sufficient to start development. At any point you have enough context and can find your way back out — because the mindmap shows the full structure.

This is Grammar → Logic → Rhetoric in practice:
1. **Requirements** = Grammar (gather the questions)
2. **PDSA cycles within requirements** = Logic (answer the questions, verify the answers)
3. **Features + Infrastructure** = Rhetoric (build, only when the thinking is solid)

### 4. The Node Model: Intrinsic Properties

Building on v3's recursive node and the refinement research (RCAA + I/O contracts), every node in the mindmap carries its own identity. The node knows what it needs, what it produces, and when it's done. This is Thomas's "object-oriented" requirement: the task itself knows its entry and exit criteria.

#### 4.1 Unified Node Schema

```yaml
node:
  id: string                    # Unique identifier
  title: string                 # Human-readable name of the thought
  owner: string                 # Who owns this thought: thomas | orchestrator | pdsa-agent | dev-agent
  type: string                  # task | quality-gate | decision | scope-break | milestone | pdsa-cycle

  # --- Intrinsic: Definition of Ready (DoR) ---
  # "What must be true before this node is workable?"
  definition_of_ready:
    context: string|null        # What the agent needs to know (from RCAA)
    inputs:                     # Explicit upstream dependencies with artifacts
      - from: string            # Source node ID
        type: string            # file | state | analysis
        description: string
        path: string|null       # File path (if type=file)
    status: string              # not_ready | ready
    # A node is "ready" when all inputs are available and context is clear.

  # --- Intrinsic: Definition of Done (DoD) ---
  # "What must be true for this node to be complete?"
  definition_of_done:
    action: string|null         # What to do — imperative instruction (from RCAA)
    acceptance: string|null     # Verifiable completion criteria (from RCAA)
    quality_gates:              # Structured verification checkpoints
      - name: string
        status: string          # pending | pass | fail
        verifier: string        # Agent ID or "thomas"
    outputs:                    # What this node produces for downstream
      - type: string            # file | state | analysis
        description: string
        path: string|null
    status: string              # not_done | done
    # A node is "done" when all quality gates pass and all outputs exist.

  # --- State ---
  status: string                # pending | active | paused | complete | failed | blocked
  pdsa_phase: string|null       # plan | do | study | act | complete | null
  pdsa_ref:                     # Reference to PDSA document (dual-link)
    git_url: string|null        # Human-readable: GitHub URL
    local_path: string|null     # Agent-readable: filesystem path

  # --- Structure ---
  dependencies: [string]        # Node IDs that must complete first (blocking)
  children: [node]              # Recursive: sub-thoughts at any depth
```

#### 4.2 The Self-Aware Node: Why DoR and DoD Are Intrinsic

##### Thomas's Vision (Verbatim — Iteration 2, 2026-02-02)

> "Let us zoom in to ensure you understand my thought: let us compare to an already solved real-life application. IP packages, or better to grasp let's also discuss logistics. When a warehouse is constructed, on the software side the stations are defined based on their capabilities and processes there. The package (containers...) know their process and book themselves into the varieties of options — like getting wrapped, made ready for shipping, the containers book themselves the next flight and truck and so on. The infrastructure just optimizes the current flow, the logic itself comes from the 'self-aware' container. And the same thought I am applying into this point. I want to think object oriented. The process is defined in the object and it knows what needs to be tested. So the tests need to be created. The object knows that and books itself into the service station where the infrastructure is creating the test case. Based on its location within the mindspace, the station receives all needed context and can fulfill its task. That can be automatically done through AI or human developers. We are at the moment only focusing on the object itself."

##### The Logistics Analogy

In a modern warehouse, there are two distinct layers:

1. **Stations (Infrastructure):** Wrapping stations, labeling stations, loading docks, shipping lanes. Each station has capabilities — it can wrap, label, scan, load. The station doesn't decide what happens to a container. It provides a service.

2. **Containers (Self-Aware Objects):** A container knows its own process. It knows: "I need to be wrapped, then labeled, then loaded onto flight LH-442, then onto truck T-7 to Munich." The container *books itself* into the stations it needs. The wrapping station doesn't decide which containers to wrap — the container arrives and says "wrap me, here are my dimensions and fragility requirements."

The infrastructure (stations) optimizes throughput — scheduling, parallel processing, load balancing. But the **logic of what needs to happen** lives in the container, not in the infrastructure.

##### The IP Packet Analogy

An IP packet carries its own destination address, protocol, TTL, and flags. The network (routers, switches) routes the packet, but it doesn't decide where the packet goes. The packet itself declares: "I'm going to 10.33.33.2, I'm TCP, I need reliable delivery." The network provides the service; the packet defines the need.

##### Applied to the Mindmap Node

The mindmap node IS the self-aware container. It is not a passive record that infrastructure acts upon — it is an active object that knows its own lifecycle:

| Container (Logistics) | IP Packet | Mindmap Node |
|----------------------|-----------|--------------|
| Knows its process (wrap → label → ship) | Knows its destination and protocol | Knows its DoR and DoD (what inputs it needs, what tests must pass, what outputs it produces) |
| Books itself into stations | Routes itself through the network | Books itself into service stations (test creation, code review, deployment) |
| Carries its own requirements (fragility, dimensions) | Carries its own headers (TTL, flags) | Carries its own context (RCAA: role, context, action, acceptance) |
| Station receives the container and fulfills its service | Router receives the packet and forwards it | Station (AI agent or human) receives the node's context and fulfills its task |

**The critical distinction:**

- **The node (object):** Defines WHAT needs to happen. Knows its own process. Carries its own entry criteria (DoR), exit criteria (DoD), and test requirements. This is what we are defining now.
- **The infrastructure (stations):** Provides HOW things get done. Creates test cases, runs builds, deploys code, reviews quality. Receives context from the node's position in the mindspace graph. This comes later.

##### What the Node Knows About Itself

A self-aware mindmap node carries:

1. **Its process** — What steps does this thought need to go through? (captured in `pdsa_phase`: plan → do → study → act)
2. **Its readiness requirements** — What must exist before work can begin? (captured in `definition_of_ready`: context, inputs)
3. **Its completion requirements** — What must be true when done? (captured in `definition_of_done`: acceptance criteria, quality gates, outputs)
4. **Its test requirements** — What needs to be tested? The node declares this; the testing station creates and runs the tests. (captured in `definition_of_done.quality_gates` — the node says "test X must pass," the infrastructure figures out how to test it)
5. **Its context** — Based on its location in the mindspace tree, any service station that processes this node receives the full path context (parent nodes, sibling nodes, the scope stack)

##### Why This Matters: Object vs. Infrastructure

In traditional PM, the process is external: a Jira workflow defines states, a CI pipeline defines tests, a team lead defines "done." The task is passive data that flows through external processes.

In mindspace, the process is intrinsic: the node defines its own states, declares its own test requirements, knows its own "done." The infrastructure (agents, tooling, dashboard) serves the node — it doesn't define it.

This is the same inversion that made logistics and networking scalable: push intelligence into the object, keep infrastructure generic and service-oriented.

**Current scope:** We are defining the object (the node schema, DoR, DoD, self-awareness). The infrastructure (service stations, automation, agent dispatch) is a future concern. The object must be right first — everything else builds on it.

#### 4.3 Status Derivation

Leaf nodes are set manually. Non-leaf nodes derive status from children:

```
complete  : ALL children complete AND definition_of_done.status = done
active    : at least one child is active
paused    : was active, now suspended
blocked   : definition_of_ready.status = not_ready (inputs missing)
failed    : any quality gate has status "fail"
pending   : not yet started
```

#### 4.4 Process Resilience: The Three-Actor Model and Zero-Knowledge Agents

##### Thomas's Vision (Verbatim — Iteration 3, 2026-02-02)

> "Let's reflect upon that point. This might be too fragile. While it is good for prototyping, the process is not resilient enough potentially, as any agent can decide to delete nodes or to manually set notes to done and the systemic approach is bypassed. I want the agent that works in a station not being able to change the process. So the process must be programmatic. We do not want an agent that understands the process and maintains it. It must be a zero knowledge thing. Package comes in, we have options, package books it into certain states, agents that are in a station as e.g. developer agent can then work on those that are in the correct state. While we will iterate this in future I want you to be aware of it right now to reflect upon it. Think about it, document it and tell me what you think, what does this thought do to your current map?"

##### The Problem with YAML-Editing-By-Agents

The current prototyping approach: agents edit YAML files directly, Hugo renders them, other agents read. This works for iteration but has a fundamental flaw — **process integrity depends on agent discipline, not enforcement.**

Any agent can:
- Mark a node as "complete" without quality gates passing
- Delete nodes from the tree
- Skip the DoR and start working on a node that isn't ready
- Restructure the tree without authorization

This is "trust-based process" — the same as a warehouse where any worker can walk to any station and stamp any package as "shipped" without it actually being shipped. It works when you have one trusted worker. It breaks at scale or with autonomous agents.

##### The Three-Actor Model

Thomas's insight completes the architecture. There are not two actors (object + infrastructure) but three, each with a distinct role and distinct permissions:

| Actor | Role | Permissions | Analogy |
|-------|------|-------------|---------|
| **Node** (Object) | Defines WHAT needs to happen | Declares its own DoR, DoD, process, test requirements | The self-aware container that knows its routing |
| **Infrastructure** (State Machine) | Enforces HOW transitions happen | Validates transitions, enforces gates, controls visibility | The warehouse routing system / network protocol |
| **Agent** (Station Worker) | Does the WORK within a station's scope | Can only act on nodes in the correct state for their station; cannot change process, delete nodes, or skip gates | The warehouse worker at the wrapping station |

The key principle: **the agent is zero-knowledge about process management.** The developer agent doesn't understand DoR/DoD transitions — it receives a node that the infrastructure has determined is "ready for implementation," does the work, produces outputs, and hands back. The infrastructure then validates whether the outputs satisfy the node's DoD before allowing the transition to "complete."

##### Extending the Logistics Analogy

In iteration 2, we established: containers know their process, stations provide services. Now we add the missing piece — the worker:

- **Container** (node): "I need wrapping with fragile-handling protocol, then labeling with customs declaration, then flight LH-442."
- **Routing system** (infrastructure): Validates the container's requirements, assigns it to the correct sequence of stations, enforces that wrapping must complete before labeling can start.
- **Worker at wrapping station** (agent): Receives the container. Wraps it. Doesn't know about labeling, flights, or customs. Doesn't decide what station comes next. Just wraps. If the wrapping doesn't meet the container's fragility requirements, the routing system rejects it and sends it back.

The worker has **zero knowledge** of the overall process. They are skilled at their station's task. The routing system controls flow. The container defines requirements.

##### What This Does to the Current Vision

This insight has three consequences for the mindspace architecture:

**1. YAML editing is the prototyping phase, not the target.**

The current YAML-editing approach is valid for now — we're in Grammar phase (gathering and structuring thoughts). But the target architecture requires a programmatic layer between agents and the mindmap data:

| Phase | How nodes are managed | Process enforcement |
|-------|----------------------|-------------------|
| **Prototyping (now)** | Agents edit YAML directly | Trust-based — protocols in CLAUDE.md |
| **Target** | Agents call a state machine API (MCP tools) | Programmatic — code enforces valid transitions |

**2. The MCP server becomes the infrastructure layer.**

The xpollination-mcp-server is not just a content pipeline tool — it becomes the state machine that enforces mindspace process:

- `mindspace_get_ready_nodes(station: "dev")` → returns only nodes whose DoR is satisfied and that are assigned to the dev station
- `mindspace_submit_output(node_id, outputs)` → infrastructure validates outputs against the node's DoD, transitions state if satisfied
- `mindspace_book_transition(node_id, target_state)` → the node (via an orchestrating process) requests a transition; infrastructure validates it

Agents never write to the YAML directly. They interact through constrained API endpoints that enforce the rules.

**3. Agent prompts become simpler, not more complex.**

A zero-knowledge agent doesn't need to understand CLAUDE.md protocols for process management. It receives: "Here is a node. Here is the context. Here is what needs to be done. Here is what 'done' looks like. Do the work." The agent focuses entirely on the skill of its station (coding, testing, planning, reviewing).

This is actually easier to build and more reliable: the current approach requires every agent to understand and follow complex protocols. The target approach requires agents to only be good at their craft — the infrastructure handles the rest.

##### Current Scope Reminder

We are defining the **object** (the node). The infrastructure (state machine, MCP tools, transition validation) and the agent model (station-scoped, zero-knowledge) are documented here as architectural direction. Implementation of the programmatic layer is a future phase. The node schema must be right first — it defines the contracts that infrastructure will enforce and agents will fulfill.

### 5. The Dual-Link Pattern

Thomas requires that every cross-repo reference has two forms:
- **Human-readable**: GitHub URL (for people with browser access)
- **Agent-readable**: Local filesystem path (for agents running on the server)

This applies to:
- `pdsa_ref` on any node
- Cross-repo navigation (from mindspace node to the actual repo)
- Any file reference in inputs/outputs

#### 5.1 Dual-Link Schema

```yaml
# On any reference field:
pdsa_ref:
  git_url: "https://github.com/PichlerThomas/HomeAssistant/blob/main/systems/hetzner-cx22-ubuntu/pdca/claude-code-setup/2026-02-02-UTC-1100.claude-session-launcher-fix.pdsa.md"
  local_path: "/home/developer/workspaces/github/PichlerThomas/HomeAssistant/systems/hetzner-cx22-ubuntu/pdca/claude-code-setup/2026-02-02-UTC-1100.claude-session-launcher-fix.pdsa.md"
```

#### 5.2 Cross-Repo References

When a mindspace node references content in another repo (e.g., infrastructure docs in HomeAssistant, code in xpollination-mcp-server), the dual-link ensures both humans and agents can navigate:

```yaml
# Example: a mindspace node linking to infrastructure documentation
node:
  id: "infra-hetzner-setup"
  title: "Hetzner CX22 Server Setup"
  definition_of_ready:
    inputs:
      - from: "homeassistant-repo"
        type: "file"
        description: "Server credentials and access docs"
        path:
          git_url: "https://github.com/PichlerThomas/HomeAssistant/blob/main/systems/hetzner-cx22-ubuntu/credentials.md"
          local_path: "/home/developer/workspaces/github/PichlerThomas/HomeAssistant/systems/hetzner-cx22-ubuntu/credentials.md"
```

### 6. Graph Traversal and Node Rearrangement

Thomas requires:
- **Traverse the whole graph back and forth** — navigate from any node to any other node
- **Drag-and-drop nodes between branches** — when thinking shifts, move a thought to where it belongs now

#### 6.1 Traversal

The mindmap is a tree (not a DAG). Navigation:
- **Down**: expand children to go deeper into a thought
- **Up**: collapse to parent to zoom out
- **Scope stack**: the path from root to the currently focused node — clickable breadcrumb
- **Cross-reference**: follow `pdsa_ref` or `inputs[].from` links to jump to related nodes

The dashboard renders the tree with expand/collapse (from v3 design: flattened tree with depth-based indentation). The scope stack breadcrumb enables quick jumps to any ancestor.

#### 6.2 Node Rearrangement (Drag-and-Drop)

When a thought no longer belongs under its current parent:
1. Drag the node from its current position
2. Drop it under a different parent (same depth or different depth)
3. The node keeps its children, DoR, DoD, and all intrinsic properties
4. References to this node (via `dependencies` or `inputs[].from`) remain valid because they use the node's `id`, not its position

Technical: SortableJS (already in v2/v3 stack) supports nested sortable lists. Moving a node between parents is a remove-from-old + insert-into-new operation on the YAML tree.

**Why this matters**: Thomas's thinking evolves. A task that started as infrastructure might become a mindspace concern. A content pipeline idea might spawn a new top-level project. The mindmap must be as fluid as the thinking.

### 7. Root Cause Analysis Alignment

Thomas values the root-cause approach. In the mindmap, root cause analysis maps naturally:

- A **problem** is a node (type: `task` or `decision`)
- **Investigation** creates children — each possible cause is a child node
- **Evidence** is captured in each child's `outputs[]`
- The **root cause** is the child node that gets status `complete` with quality gates passing
- **Fix** is a sibling or child of the root cause node
- The whole investigation is visible as a sub-tree in the mindmap

This replaces ad-hoc debugging with structured decomposition, visible in the same tree as everything else.

### 8. Agent Registry

Unchanged from v3. Agents are defined once, referenced by ID:

```yaml
meta:
  agents:
    thomas:
      display: "Thomas"
      color: "amber"
      role: "Strategic direction, approval, Definition of Done verifier"
    orchestrator:
      display: "Orchestrator"
      color: "indigo"
      role: "Coordination, relay, quality gates, focus enforcement"
    pdsa-agent:
      display: "PDSA"
      color: "violet"
      role: "Planning, research, PDSA documentation, quality review"
    dev-agent:
      display: "Dev"
      color: "emerald"
      role: "Implementation, git commits, operational execution"
```

### 9. Evolution from v1 to Mindspace

| Version | Model | Key Insight |
|---------|-------|-------------|
| v1 | Flat YAML: phases → items → sub_items | Hierarchical view matches mental model |
| v2 | Added PDSA phase indicators, scope breaks, quality gates | The process itself needs visualization |
| v3 | Recursive tree: one node type, unbounded depth, agent assignments | Depth emerges from work complexity, not fixed structure |
| Refinement | RCAA pattern, input/output contracts, single-repo PDSAs | Tasks must be self-contained and chainable |
| **Mindspace** | **Mindmap: thoughts with intrinsic DoR/DoD, dual-links, graph traversal** | **The tool IS the shared mental model, not just a tracker** |

Each version added a dimension. Mindspace synthesizes all of them.

### 10. Migration Plan

#### 10.1 PDSA Location Principle

**PDSAs live with their project.** Each project's PDSAs stay in that project's repo — they need the surrounding context (code, configs, other docs) to be meaningful.

| Project | PDSA Location | Notes |
|---------|---------------|-------|
| xpollination-mindspace | `docs/pdsa/` | Mindspace vision, methodology PDSAs |
| xpollination-mcp-server | `docs/pdsa/` (new files) and `docs/pdca/` (historical files pre-2026-01-30) | Infrastructure layer, content pipeline PDSAs |
| HomeAssistant | `systems/*/pdca/` | Infrastructure operation PDSAs |

Cross-repo references use dual-links (Section 5) so any agent in any repo can find related PDSAs.

**Historical note:** An earlier iteration proposed centralizing all PDSAs in one repo. Thomas corrected this — "MCP server PDSAs need to go into the MCP server project or we lose context." Each project is a self-contained unit of thought; its PDSAs are part of that thought.

#### 10.2 Data Model Migration (v2 YAML → Mindspace YAML)

The existing `currentContext.yaml` uses v2 structure (phases → items → sub_items). Migration:

1. Each `phase` becomes a node at depth 0 under its project root
2. Each `item` becomes a child node at depth 1
3. Each `sub_item` becomes a child node at depth 2
4. `quality_gates` move into `definition_of_done.quality_gates`
5. `pdsa_ref` becomes a dual-link object
6. Free-text `description` fields with RCAA pattern get split into `definition_of_ready.context` + `definition_of_done.action` + `definition_of_done.acceptance`

This is mechanical — no data loss.

### 11. What Mindspace Is NOT

To prevent scope creep:

- **Not a Jira clone.** No sprints, no story points, no velocity charts. PDSA replaces sprints.
- **Not a knowledge base.** Documentation lives in repos. The mindmap links to it — it doesn't duplicate it.
- **Not an agent runtime.** Agents read the mindmap for context, but execution happens in tmux/Claude Code. The mindmap is the map, not the territory.
- **Not trust-based process management (target).** The prototyping phase uses YAML editing by agents — this is fragile and acceptable only for iteration. The target architecture is a programmatic state machine where agents cannot bypass process (see Section 4.4). The transition from prototyping to enforcement is a major milestone.

### 12. Quality Gates for This PDSA

| Gate | Criteria | Verifier |
|------|----------|----------|
| QG-1 | Node schema includes intrinsic DoR and DoD as fields on the node | pdsa-agent |
| QG-2 | Dual-link pattern documented with concrete examples | pdsa-agent |
| QG-3 | Graph traversal and drag-and-drop requirements documented | pdsa-agent |
| QG-4 | Migration plan covers all existing PDSAs and dashboard data | pdsa-agent |
| QG-5 | Vision aligns v3 recursive tree with Thomas's mindmap metaphor | pdsa-agent |
| QG-6 | Trivium Method documented as foundational thinking framework, connected to PDSA | pdsa-agent |
| QG-7 | Mindspace internal structure (features, infrastructure, requirements) replaces workspace mapping | pdsa-agent |
| QG-8 | Three-actor model documented: node (object), infrastructure (state machine), agent (zero-knowledge worker) | pdsa-agent |
| QG-9 | Prototyping vs target architecture explicitly distinguished | pdsa-agent |
| QG-10 | Thomas approves vision as matching his intent | thomas |

**Self-assessment (QG-1 through QG-9):**
- QG-1: PASS — Section 4.1 defines `definition_of_ready` and `definition_of_done` as intrinsic node fields
- QG-2: PASS — Section 5 defines dual-link schema with concrete YAML examples
- QG-3: PASS — Section 6 documents traversal (scope stack, expand/collapse) and drag-and-drop (SortableJS)
- QG-4: PASS — Section 10 lists all files to migrate with source/target paths
- QG-5: PASS — Section 1 maps every PM concept to a mindmap concept; Section 9 traces the evolution
- QG-6: PASS — Section 2 documents Grammar→Logic→Rhetoric with explicit mapping to mindmap activities and PDSA phases
- QG-7: PASS — Section 3 defines Requirements/Features/Infrastructure as internal mindspace structure
- QG-8: PASS — Section 4.4 defines the three-actor model with role/permission table and extended logistics analogy
- QG-9: PASS — Section 4.4 distinguishes prototyping (YAML editing, trust-based) from target (MCP state machine, enforced); Section 11 updated

**QG-10: PASS — Thomas approved the vision on 2026-02-02. Proceeding to Grammar phase (zooming in with questions).**

### 13. Grammar Phase: Strategic Decisions (Thomas, 2026-02-02)

#### 13.1 MVP Scope (Q16)

**Thomas's decision:** MCP state machine only. No dashboard for MVP.

> "We need a flow to provide quality software that is tested and resilient and also in which the requirements are linked to the code so we at all time know what impact changes will have. This is a new requirement that you need to document and to describe. So the output of it will be linked to the PDSA in which this will be described. So when we have a change you can determine the impact and receive the possibility to iterate the software while keeping the quality."

**Implications:**
- Dashboard features (graph traversal, drag-drop, DoR/DoD display) are deprioritized
- MCP state machine enforcement is the first deliverable
- **New requirement identified:** Requirements-to-code traceability — every piece of code must link back to the PDSA/requirement that defined it, enabling impact analysis when changes are proposed

#### 13.2 Build Order (Q17)

**Thomas's decision:** MCP enforcement first. Visualization comes later.

> "The focus is the MCP enforcement. Visualization comes later. Document it that we are reminded on it but we can deprioritize it."

**Implications:**
- Dashboard/visualization work (Hugo, Alpine.js, SortableJS features) moves to a future phase
- All UX & Dashboard questions (Q21–Q24) remain documented but are lower priority

#### 13.3 Server Architecture (Q18)

**Thomas's decision:** Single MCP server. Optimize, learn, iterate.

> "We have 1 MCP server for now. Optimizing that and then make the final product and iterate through our learnings."

**Implications:**
- Content pipeline and mindspace tools coexist in one MCP server
- Shared SQLite database, shared Node.js process
- Split can happen later based on learnings

#### 13.4 Migration Strategy (Q19)

**Thomas's decision:** Big bang migration. YAML as backup.

> "As we do not have production we can plan big bang and use YAML for backup if transition was not working and iterate until it worked."

**Implications:**
- Write import script to load mockup YAML into SQLite
- Keep YAML as rollback safety net
- No dual-write or gradual migration — no production users

#### 13.5 Resource Budget (Q20)

**Thomas's decision:** Keep lightweight, but not hard-restricted. Server upgrade possible.

> "I might upgrade to bigger server. So keep it lightweight in general is my preference but we are not restricted."

**Implications:**
- SQLite is the right choice (minimal resource footprint)
- No need for PostgreSQL or other heavy infrastructure
- Design for lightweight but don't over-optimize for constraints that may change

### 14. Grammar Phase: Node Types and State Machine (Q1 + Q6, 2026-02-02)

#### 14.1 Method: Observation-Driven Design

Rather than theorizing, the orchestrator observed the ACTUAL states and types we lived through during the Grammar phase Q&A cycles. This observation was compared against enterprise best practices, then distilled into a minimal-but-sufficient model.

**Enterprise patterns consulted:**
- Kanban (minimal states with WIP limits)
- Azure DevOps / JIRA (type-specific workflows)
- SAFe (Funnel → Analyzing → Implementing → Validating → Deploying)
- BPMN (gateway types, events vs activities)

**Key enterprise principle adopted:** Different work item types have different valid workflows. A decision has different states than a task. But we do NOT need JIRA-level complexity — we need the minimum set that covers what we actually experience.

#### 14.2 Canonical Status Set (Q6 — ANSWERED)

> Q6: yes! matches

**The problem:** Vision PDSA listed 6 statuses, MCP Infra PDSA listed 9. The orchestrator observed states we live through that had NO name in either set.

**The solution: 8 canonical statuses**, derived from observation:

| Status | What it means | Observed in practice |
|--------|--------------|---------------------|
| `pending` | Created, DoR not satisfied | Q1-Q6 before Thomas answers |
| `ready` | DoR satisfied, waiting for agent to claim | After Thomas answers, before PDSA agent starts |
| `active` | Agent is working | PDSA agent editing files |
| `review` | Work submitted, awaiting verification | After commit, waiting for Thomas to review |
| `rework` | Review found issues, returned to agent | Thomas: "traceability node missing pdsa_ref" |
| `complete` | All quality gates pass, done | Thomas approves |
| `blocked` | Explicitly blocked by external factor or scope break | Paused for child PDSA, external dependency |
| `cancelled` | Terminal: deliberately abandoned | Node no longer relevant |

**What was dropped and why:**
- `paused` → subsumed into `blocked` (a scope break blocks the current node)
- `failed` → replaced by `cancelled` (clearer intent — "failed" implies quality failure, "cancelled" is a deliberate choice; quality failures go through `rework`)

**Transition rules:**
```
pending → ready          (automatic: all DoR inputs available)
ready → active           (agent claims the node)
active → review          (agent submits output)
review → complete        (all quality gates pass)
review → rework          (quality gate fails)
rework → active          (agent restarts work)
ANY → blocked            (external factor or scope break)
blocked → ready          (blocker resolved)
ANY → cancelled          (deliberate abandonment)
```

#### 14.3 Node Types (Q1 — ANSWERED)

> Q1: we need to see later on at this moment i cannot imagine it. so we go with your suggestion for now.

**The problem:** Schema defined 6 types. The orchestrator observed types we USE that were missing, and types we defined that were redundant.

**The solution: 5 node types**, each with a distinct lifecycle:

| Type | Purpose | Valid States | Example |
|------|---------|-------------|---------|
| `task` | Standard work item with DoR/DoD | All 8 states (full lifecycle) | "SQLite schema extension" |
| `pdsa-cycle` | Full PDSA iteration, extends task with `pdsa_phase` tracking | All 8 states + pdsa_phase | "What is the mindspace vision?" |
| `group` | Organizational container, status derived from children | `pending`, `active`, `complete`, `blocked`, `cancelled` | "Requirements", "Features" |
| `decision` | Choice point — answer IS the completion | `pending`, `ready`, `active`, `complete`, `blocked`, `cancelled` (no review/rework — the decider's answer is final) | Q16-Q20 |
| `milestone` | Progress marker — no work, just a gate | `pending`, `complete`, `blocked`, `cancelled` (binary: reached or not) | "Grammar phase complete" |

**What was dropped and why:**
- `quality-gate` → Not a node type. Quality gates are a PROPERTY of any node (already in `definition_of_done.quality_gates`). Having "quality-gate" as both a type and a field is confusing.
- `scope-break` → Not a node type. It's an EVENT that happens during work (discovering new scope creates new child nodes). The act of creating a child node IS the scope break. No separate type needed.

**Why `group` was added:** Nodes like "Requirements", "Features", "Infrastructure" are not tasks. They don't have their own work — they aggregate children. The orchestrator observed these have no meaningful DoR/DoD of their own. A `group` derives its status: `active` if any child is active, `complete` when all children complete.

**Why `decision` is distinct from `task`:** In our process, Q16-Q20 were decisions. Thomas answered, PDSA documented, done. There is no review/rework loop — Thomas's decision IS the final word. A task goes through review; a decision goes through deliberation then is final.

#### 14.4 Updated Schema (Section 4.1 Amendment)

The `type` field in the unified node schema (Section 4.1) is amended:

```yaml
type: string  # task | pdsa-cycle | group | decision | milestone
```

The `status` field is amended:

```yaml
status: string  # pending | ready | active | review | rework | complete | blocked | cancelled
```

The state machine enforces type-specific valid transitions per Section 14.3.

---

### 15. Grammar Phase: DAG, UUIDs, Lifecycle Types & Agent Chains (Q2-Q5, 2026-02-02)

#### 15.1 DAG Structure (Q2 — ANSWERED)

**Thomas's decision:** DAG, not tree. DRY principle.

> "We need DAG! As we are operating in a DRY Pattern we do not want to replicate multiple functionality with the same but a little bit different implementation. That is not possible to scale."

**Why tree fails:** "SQLite Schema Extension" is needed by BOTH "State Machine API" and "Data Migration." In a tree, you'd duplicate the node — changes to one copy don't propagate. This violates DRY and breaks traceability.

**Schema change:** `parent_id: string` becomes `parent_ids: [string]`. A node can have multiple parents. Display rendering picks one primary parent for layout; all parents are structural.

```yaml
# Section 4.1 amendment
parent_ids: [string]          # DAG: multiple parents allowed (DRY)
# replaces: parent_id: string  (was single parent, tree only)
```

**Implications for state machine:** When a node completes, ALL parents that depend on it get notified (not just one). The `pending → ready` auto-detection must check all downstream nodes across all parent paths.

#### 15.2 UUID Primary Keys (Q3 — ANSWERED)

**Thomas's decision:** UUID.

> Q3: UUID

```yaml
# Section 4.1 amendment
id: uuid                      # System-generated UUID
slug: string|null             # Optional human-readable display alias
```

**Why:** UUIDs are stable across drag-drop, reparenting, DAG restructuring. Human-readable slugs are display aliases only — the system references by UUID. This also enables the DAG: you reference a node by its stable UUID from multiple parents.

#### 15.3 Lifecycle Node Types (Q4 — ANSWERED)

**Thomas's verbatim:**

> when we are having multiple domains we need to specify them and create a described and therefore iterable way forward, when we need to scale it. provide again a list based on your observations and enterprise standards of a typical it lifecycle. how to get from thought to testable product that is fully tracable and where we see immidiatly what gaps exist during the planning phase, where we can define the to be tested milestones, where we can define the non functional requiremnts etc.

**Method:** Combined V-Model (specification ↔ verification), SAFe hierarchy (Epic → Feature → Story → Task), and our observed PDSA process into a minimal lifecycle.

**The Lifecycle (left = specification, right = verification):**

```
Thought → Requirement → Design → Task → Test → Deployment
                                  ↑               ↑
                             NFR ─┘         Integration ─┘
```

**9 lifecycle types + 3 structural types = 12 node types:**

| Type | Purpose | Valid States | Creates | Executes | Verifies |
|------|---------|-------------|---------|----------|----------|
| **Specification side** |||||
| `requirement` | What needs to be built | all 8 | PDSA | PDSA | Thomas |
| `design` | Architecture: how to build it | all 8 | PDSA | PDSA | Thomas + Dev |
| `nfr` | Non-functional requirement (perf, security) | all 8 | PDSA | PDSA | QA |
| **Implementation** |||||
| `task` | Code implementation | all 8 | PDSA | Dev | QA |
| `deployment` | Release to environment | all 8 | PDSA | Dev | Orchestrator |
| **Verification side** |||||
| `test` | Verify implementation against spec | all 8 | QA/PDSA | QA | PDSA |
| `integration` | Verify components work together | all 8 | QA/PDSA | QA | PDSA |
| **Cross-cutting** |||||
| `decision` | Choice point (Thomas decides) | pending, ready, active, complete, blocked, cancelled | PDSA | Thomas | N/A |
| `pdsa-cycle` | Quality iteration (wraps any work) | all 8 + pdsa_phase | PDSA | varies | Thomas |
| **Structural** |||||
| `group` | Container (status from children) | pending, active, complete, blocked, cancelled | Any | N/A | N/A |
| `milestone` | Progress gate (binary) | pending, complete, blocked, cancelled | PDSA | N/A | Thomas |
| `project` | Top-level project container | pending, active, complete | Thomas | N/A | N/A |

**Traceability chain (thought → testable product):**
```
requirement → design → task ← test
                  ↓              ↑
                nfr ──────→ integration
```
Every `task` traces back to a `design` which traces to a `requirement`. Every `test` traces to the `task` it verifies AND the `requirement`/`nfr` it validates. Gaps are visible: a `requirement` with no `design` child = architecture gap. A `task` with no `test` = coverage gap.

#### 15.4 Process Chains Per Type & Agent Roles (Q5 — ANSWERED)

**Thomas's verbatim:**

> yes that is relevant... we did not think it through until now. i think its not needed at this moment. we need to define in detail the flow for each type that is defined in Q4 and for each type there is a different process then. for example requirement: what is the process chain? orchestrator you observed it right now. you did break the pattern once because it was easier. then you realized you need to do it right. so we need to define that pattern who is doing what so that the chain of deliverables is done correctly. when we come after the requiremnt phase to development then there is a test to be created. who is doing that? at the moment we have orchestrator, pdsa and dev - that might be too less. i can add 4gb ram so we can spin up more agents if we need to.

##### Process Chains (observed + projected)

**Requirement chain:**
```
Thomas (concept) → Orchestrator (brief) → PDSA (research, document) →
Orchestrator (verify against intent) → Thomas (approve/iterate)
```

**Design chain:**
```
PDSA (architecture proposal) → Orchestrator (relay) →
Dev (feasibility review) → Orchestrator → Thomas (approve/iterate)
```

**Task (implementation) chain:**
```
PDSA (defines DoR/DoD/quality gates) → Orchestrator (quality-gate plan) →
Dev (implements, commits) → QA (tests against spec) →
PDSA (reviews result vs plan, updates STUDY/ACT) → Orchestrator → Thomas (approve)
```

**Test chain:**
```
PDSA (defines what to test from DoD) → QA (writes tests, executes) →
PDSA (reviews coverage against requirement) → Orchestrator → Thomas (approve)
```

**NFR chain:**
```
PDSA (defines NFR criteria) → Orchestrator → QA (tests: load, security, etc.) →
PDSA (reviews against criteria) → Orchestrator → Thomas (approve)
```

##### Agent Roles (4 agents recommended)

| Agent | Role | Types it handles | When active |
|-------|------|-----------------|-------------|
| **Orchestrator** | Coordinate, relay, monitor, quality-gate | All (meta) | Always |
| **PDSA** | Plan, document, review against spec, STUDY/ACT | requirement, design, nfr, pdsa-cycle, decision | Requirements + Design + Review phases |
| **Dev** | Implement code, deploy, commit | task, deployment | Implementation phase |
| **QA** | Write tests, verify implementation, check NFRs | test, integration, nfr (execution) | Testing + Integration phases |

**Key principle:** No agent grades its own work. Dev implements → QA tests. PDSA plans → Dev implements. QA tests → PDSA reviews test coverage against spec.

##### RAM Budget (with Thomas's 4GB upgrade)

| Agent | RAM | Notes |
|-------|-----|-------|
| Orchestrator | ~100MB | Lightweight coordination |
| PDSA | ~2.5GB | Claude Code instance |
| Dev | ~2.5GB | Claude Code instance |
| QA | ~2.5GB | Claude Code instance |
| **Total** | **~7.6GB** | Fits in 8GB with headroom |

**Note:** Not all agents need to run simultaneously. During Grammar phase (now), only Orchestrator + PDSA are active. During implementation, Dev + QA are active. PDSA can be suspended to free RAM when not needed.

#### 15.5 Section 4.1 Schema Amendments Summary

All Q1-Q6 answers amend Section 4.1:

```yaml
node:
  id: uuid                    # Q3: UUID primary key
  slug: string|null           # Q3: Optional human-readable alias
  title: string
  owner: string
  type: string                # Q1/Q4: requirement | design | nfr | task | deployment |
                              #        test | integration | decision | pdsa-cycle |
                              #        group | milestone | project
  parent_ids: [uuid]          # Q2: DAG — multiple parents (DRY principle)
  status: string              # Q6: pending | ready | active | review | rework |
                              #     complete | blocked | cancelled
  # ... rest of schema unchanged (DoR, DoD, pdsa_phase, pdsa_ref)
```

#### 15.6 Process Chains as Structured YAML

The textual process chains (Section 15.4) converted to structured YAML for implementation. Each chain defines: who creates the node, who works at each status, and who verifies completion.

```yaml
# =============================================================================
# PROCESS CHAINS BY NODE TYPE
#
# Each type has a defined chain: who does what at which status.
# The state machine enforces these — an agent can only act on a node
# if they are the designated actor for that type at that status.
# =============================================================================

process_chains:

  # ---------------------------------------------------------------------------
  # SPECIFICATION TYPES (Grammar/Logic phases)
  # ---------------------------------------------------------------------------

  requirement:
    description: "What needs to be built — captured from Thomas's direction"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    chain:
      - status: pending
        actor: system
        action: "Auto-created or created by PDSA from Thomas input"
      - status: ready
        actor: orchestrator
        action: "Brief the requirement to PDSA agent"
      - status: active
        actor: pdsa
        action: "Research, document requirement with DoR/DoD"
      - status: review
        actor: orchestrator
        action: "Verify documentation matches Thomas's intent"
      - status: complete
        actor: thomas
        action: "Approve requirement as correctly captured"
    creates: [design, task, test]  # Downstream types this enables

  design:
    description: "Architecture — how to build it"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    chain:
      - status: pending
        actor: system
        action: "Created when requirement needs architecture"
      - status: ready
        actor: orchestrator
        action: "Relay to PDSA for architecture proposal"
      - status: active
        actor: pdsa
        action: "Create architecture proposal"
      - status: review
        actor: dev
        action: "Feasibility review — is this buildable?"
      - status: complete
        actor: thomas
        action: "Approve architecture"
    creates: [task, nfr]

  nfr:
    description: "Non-functional requirement (performance, security, etc.)"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    chain:
      - status: pending
        actor: system
        action: "Created during design phase"
      - status: ready
        actor: orchestrator
        action: "Relay to PDSA for criteria definition"
      - status: active
        actor: pdsa
        action: "Define NFR criteria (measurable thresholds)"
      - status: review
        actor: qa
        action: "Review criteria are testable"
      - status: complete
        actor: thomas
        action: "Approve NFR criteria"
    creates: [test, integration]

  # ---------------------------------------------------------------------------
  # IMPLEMENTATION TYPES (Rhetoric phase)
  # ---------------------------------------------------------------------------

  task:
    description: "Code implementation work"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    chain:
      - status: pending
        actor: system
        action: "Created from design or requirement"
      - status: ready
        actor: pdsa
        action: "Define DoR/DoD/quality gates for the task"
      - status: active
        actor: dev
        action: "Implement code, commit, push"
      - status: review
        actor: qa
        action: "Test against spec, verify quality gates"
      - status: complete
        actor: pdsa
        action: "Review result vs plan, update PDSA STUDY/ACT"
    creates: [test]

  deployment:
    description: "Release to environment"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    chain:
      - status: pending
        actor: system
        action: "Created when task is ready for release"
      - status: ready
        actor: pdsa
        action: "Define deployment criteria"
      - status: active
        actor: dev
        action: "Execute deployment"
      - status: review
        actor: orchestrator
        action: "Verify deployment succeeded"
      - status: complete
        actor: thomas
        action: "Confirm production is healthy"
    creates: []

  # ---------------------------------------------------------------------------
  # VERIFICATION TYPES
  # ---------------------------------------------------------------------------

  test:
    description: "Verify implementation against spec"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    chain:
      - status: pending
        actor: system
        action: "Created from task's DoD"
      - status: ready
        actor: pdsa
        action: "Define what to test (from DoD)"
      - status: active
        actor: qa
        action: "Write tests, execute"
      - status: review
        actor: pdsa
        action: "Review coverage against requirement"
      - status: complete
        actor: orchestrator
        action: "Confirm all tests pass"
    creates: []

  integration:
    description: "Verify components work together"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    chain:
      - status: pending
        actor: system
        action: "Created when multiple tasks need integration"
      - status: ready
        actor: pdsa
        action: "Define integration criteria"
      - status: active
        actor: qa
        action: "Run integration tests"
      - status: review
        actor: pdsa
        action: "Review integration coverage"
      - status: complete
        actor: orchestrator
        action: "Confirm integration passes"
    creates: [deployment]

  # ---------------------------------------------------------------------------
  # CROSS-CUTTING TYPES
  # ---------------------------------------------------------------------------

  decision:
    description: "Choice point — Thomas decides"
    valid_statuses: [pending, ready, active, complete, blocked, cancelled]  # No review/rework
    chain:
      - status: pending
        actor: system
        action: "Question identified"
      - status: ready
        actor: pdsa
        action: "Frame the decision with options"
      - status: active
        actor: thomas
        action: "Deliberate and decide"
      - status: complete
        actor: pdsa
        action: "Document decision with verbatim quote"
    creates: []  # Decisions unblock other nodes

  pdsa-cycle:
    description: "Quality iteration wrapping any work"
    valid_statuses: [pending, ready, active, review, rework, complete, blocked, cancelled]
    pdsa_phases: [plan, do, study, act, complete]
    chain:
      - status: pending
        actor: system
        action: "PDSA cycle initiated"
      - status: ready
        actor: orchestrator
        action: "Assign to appropriate agent"
      - status: active
        actor: varies  # Depends on what the PDSA wraps
        action: "Execute PDSA phases"
      - status: review
        actor: pdsa
        action: "STUDY phase — analyze results"
      - status: complete
        actor: thomas
        action: "ACT phase — approve learnings"
    creates: []

  # ---------------------------------------------------------------------------
  # STRUCTURAL TYPES (containers, not work items)
  # ---------------------------------------------------------------------------

  group:
    description: "Container — status derived from children"
    valid_statuses: [pending, active, complete, blocked, cancelled]  # No ready/review/rework
    chain:
      - status: pending
        actor: system
        action: "Group created"
      - status: active
        actor: system
        action: "Auto: any child becomes active"
      - status: complete
        actor: system
        action: "Auto: all children complete"
    creates: []
    status_derivation:
      active: "any child.status == active"
      complete: "all children.status == complete"
      blocked: "all active children.status == blocked"

  milestone:
    description: "Progress gate — binary pass/fail"
    valid_statuses: [pending, complete, blocked, cancelled]  # No workflow, just gate
    chain:
      - status: pending
        actor: system
        action: "Milestone defined"
      - status: complete
        actor: thomas
        action: "Milestone reached"
    creates: []

  project:
    description: "Top-level project container"
    valid_statuses: [pending, active, complete]
    chain:
      - status: pending
        actor: thomas
        action: "Project initiated"
      - status: active
        actor: system
        action: "Auto: work begins"
      - status: complete
        actor: thomas
        action: "Project delivered"
    creates: [requirement, group]

# =============================================================================
# AGENT PERMISSIONS MATRIX
#
# Derived from process chains above. The state machine uses this to validate
# whether an agent can act on a node.
# =============================================================================

agent_permissions:
  thomas:
    can_create: [project, decision]
    can_complete: [requirement, design, nfr, deployment, pdsa-cycle, milestone, project]
    can_act_on:
      decision: [active]

  orchestrator:
    can_create: []
    can_complete: [test, integration, deployment]
    can_act_on:
      requirement: [ready, review]
      design: [ready]
      nfr: [ready]
      task: []
      deployment: [review]

  pdsa:
    can_create: [requirement, design, nfr, task, test, integration, pdsa-cycle, group]
    can_complete: [task, decision]
    can_act_on:
      requirement: [active]
      design: [active]
      nfr: [active]
      task: [ready]
      test: [ready, review]
      integration: [ready, review]
      decision: [ready, complete]
      pdsa-cycle: [review]

  dev:
    can_create: []
    can_complete: []
    can_act_on:
      design: [review]  # Feasibility review
      task: [active]
      deployment: [active]

  qa:
    can_create: []
    can_complete: []
    can_act_on:
      nfr: [review]
      task: [review]
      test: [active]
      integration: [active]
```

**Key principle:** No agent grades its own work.
- Dev implements → QA tests → PDSA reviews
- PDSA plans → Dev implements
- QA tests → PDSA reviews coverage

**Note on 3-pane vs 4-agent:** If using 3-pane layout (PDSA+QA combined), the combined agent has permissions of both PDSA and QA. The state machine doesn't change — it just validates against combined permissions.

---

### 16. Open Questions for Implementation

These questions emerged from Grammar phase and need resolution before implementation. Grouped by priority.

#### 16.1 Blocking for MVP Implementation

**Q-A: DAG or Tree for MVP?**
- Vision PDSA Section 15.1 says DAG (`parent_ids: [uuid]`) for DRY principle
- MCP Infra PDSA Section 5 schema has tree (`parent_id TEXT`)
- Options: (a) DAG from start, (b) Tree now + DAG later

**Q-B: 4 Agents or 3-Pane for MVP?**
- Vision PDSA Section 15.4 recommends 4 agents: Orchestrator, PDSA, Dev, QA
- CLAUDE.md documents 3-pane layout with PDSA+QA combined
- Options: (a) Keep 3-pane for MVP, (b) Move to 4 agents now

**Q-C: Requirements-to-Code Traceability Mechanism?**
- Thomas identified in Q16 (Section 13.1): code must link to requirements for impact analysis
- Mechanism undefined: Git commit refs? Code comments? Link table? Automated analysis?
- Need concrete pattern with example

**Q-D: Which Node Types for MVP?**
- Vision PDSA Section 15.3 defines 12 types with different state machines
- Options: (a) All 12 types for MVP, (b) Subset (task, group, decision) + expand later

#### 16.2 State Machine Details (Referenced in Mockup as Q7-Q11)

- Q7: How does auto-detection of `pending → ready` work? (Check all inputs satisfied)
- Q8: How does status derivation work for group nodes? (All children complete → group complete)
- Q9: What triggers `blocked` state? (Explicit flag? Scope break? External dependency?)
- Q10: Can a node transition backward (e.g., `complete → rework`)? (Audit correction scenario)
- Q11: How are transition validations logged for audit trail?

#### 16.3 MCP API Details (Referenced in Mockup as Q12-Q15)

- Q12: Should `mindspace_get_ready_nodes` support filtering by type?
- Q13: How does `mindspace_submit_output` validate file outputs exist?
- Q14: Can `mindspace_book_transition` be called by any agent or only the owner?
- Q15: How do MCP tools report validation errors? (Error response format)

#### 16.4 Zero-Knowledge Agent Protocol (Referenced in Mockup as Q25-Q29)

- Q25: What context does an agent receive when claiming a node?
- Q26: How does an agent know its station? (Hardcoded? Environment? MCP config?)
- Q27: What happens when an agent submits invalid output? (Reject + message)
- Q28: Can an agent release a node without completing it? (Abandon scenario)
- Q29: How do we prevent an agent from calling `create_node` (which is PDSA-only)?

#### 16.5 Alignment Fixes (Can Proceed with Assumption)

**Q-E: Use Vision's Status Set in MCP Infra?**
- MCP Infra diagram uses `paused`, Vision uses `blocked/cancelled`
- **Assumed: YES** — update MCP Infra to match Vision

**Q-F: Add Slug Column to MCP Infra Schema?**
- Vision Section 15.2 defines `slug: string|null`
- MCP Infra schema missing this column
- **Assumed: YES** — add `slug TEXT` column

---

## DO

*Dev agent implements MCP state machine (M.1–M.8 from MCP Infra PDSA) after Grammar phase completes and open questions (Section 16.1) are resolved.*

---

## STUDY

*Pending implementation and Thomas review.*

---

## ACT

*Pending.*

---

## REFERENCES

### Prior PDSAs (Evolution Chain)

| Document | What It Established |
|----------|-------------------|
| `2026-01-29-UTC-1445.projectmanagement-tool.pdca.md` | v1: flat YAML dashboard, Hugo + Alpine.js + SortableJS stack |
| `2026-01-30-UTC-1030.recursive-pdca-framework.pdca.md` | Recursive PDSA theory: Deming, Hoshin Kanri, fractal PM |
| `2026-01-30-UTC-1100.pm-tool-v2-implementation.pdsa.md` | v2: PDSA phase indicators, scope breaks, quality gates |
| `2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` | v3: one node type, unbounded depth, agent registry, scope stack |
| `2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` | RCAA pattern, input/output contracts, single-repo PDSAs |

### Source Locations (Dual-Links)

| Document | Git URL | Local Path |
|----------|---------|------------|
| This PDSA | `https://github.com/PichlerThomas/xpollination-mindspace/blob/main/docs/pdsa/2026-02-02-UTC-1300.mindspace-vision.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mindspace/docs/pdsa/2026-02-02-UTC-1300.mindspace-vision.pdsa.md` |
| MCP Infra PDSA | `https://github.com/PichlerThomas/xpollination-mcp-server/blob/main/docs/pdsa/2026-02-02-UTC-1500.mcp-server-infrastructure-layer.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mcp-server/docs/pdsa/2026-02-02-UTC-1500.mcp-server-infrastructure-layer.pdsa.md` |
| v3 Design | `https://github.com/PichlerThomas/xpollination-mcp-server/blob/main/docs/pdca/2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mcp-server/docs/pdca/2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` |
| Refinement | `https://github.com/PichlerThomas/xpollination-mcp-server/blob/main/docs/pdca/2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mcp-server/docs/pdca/2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` |
