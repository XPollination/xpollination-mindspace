# PDSA: Mindspace Vision — Mindmap-Based Project Management for Human-Agent Alignment

**PDSA ID:** 2026-02-02-UTC-1300.mindspace-vision
**Project:** xpollination-mindspace
**Status:** PLAN
**Created:** 2026-02-02
**Priority:** CRITICAL — Defines the foundational mental model for all projects
**Agent:** PDSA Agent

---

## MANAGEMENT ABSTRACT

**What:** Define the vision for xpollination-mindspace — a project management system built on the **mindmap** metaphor, where trees of shared thought keep humans and agents in alignment.

**Why:** The PM tool evolved through v1 (flat YAML dashboard), v2 (PDSA visualization), and v3 (recursive task tree with agent assignments). Thomas's insight: these iterations were converging toward something larger — not just a task tracker, but a **shared mental model**. The mindmap IS the alignment. Every node is a thought. Traversing the graph is traversing shared understanding.

**Outcome:** A vision document that:
1. Reframes the v3 recursive tree as a mindmap of shared thought
2. Makes Definition of Ready / Definition of Done intrinsic node properties (object-oriented)
3. Establishes the dual-link pattern for cross-repo navigation
4. Defines graph traversal and node rearrangement requirements
5. Provides a migration plan from xpollination-mcp-server to this repo

---

## PLAN

### 1. The Core Metaphor: Mindmap as Shared Mental Model

Thomas's vision: the PM tool is really a **new approach to project management** — keeping thoughts in alignment between human and agents.

The key reframe:

| PM Tool Concept | Mindmap Concept |
|-----------------|-----------------|
| Task tree | Tree of thoughts |
| Node | A thought (project, idea, task, decision) |
| Children | Deeper decomposition of a thought |
| Root nodes | Top-level projects / mental domains |
| Scope stack | Where attention is focused right now |
| Agent assignment | Who is thinking about / working on this thought |
| Quality gate | Verification that the thought was realized correctly |
| PDSA cycle | The discipline of thinking: Plan the thought → Do it → Study what happened → Act on learnings |

This is not just naming — it changes how the tool is used. A task tracker asks "what's the status?" A mindmap asks "what are we thinking about, and do we understand it the same way?"

### 2. The Trivium Method: How to Think Before What to Build

The mindmap is grounded in the **Trivium Method** — a three-stage process for systematic thinking from the classical Liberal Arts (Latin *trivium*, "the place where three roads meet"):

#### 2.1 The Three Stages

| Stage | Question | Activity |
|-------|----------|----------|
| **1. Grammar** (Knowledge / Input) | Who, what, where, when? | Gather raw facts. Map what you know. Identify the gaps — what you *don't* know. |
| **2. Logic** (Understanding / Processing) | Why? | Analyze what you've gathered. Test for contradictions, eliminate false assumptions, explore unknowns until you have a coherent, verified foundation. |
| **3. Rhetoric** (Wisdom / Output) | How? | Apply that understanding. Make sound projections, communicate a position, determine the right next step. |

**The discipline:** Strict sequence. Don't jump to conclusions or action (Rhetoric) before you've gathered facts (Grammar) and pressure-tested them (Logic). The Trivium teaches HOW to think, not WHAT to think.

#### 2.2 Trivium Maps to the Mindmap and PDSA

The Trivium is not separate from what we already do — it explains WHY the mindmap and PDSA work:

| Trivium Stage | Mindmap Activity | PDSA Phase |
|---------------|-----------------|------------|
| **Grammar** | Build the mindmap — structure all thoughts, gather requirements, map what exists and what's unknown | **Plan** — gather facts, define the problem |
| **Logic** | PDSA cycles within nodes — test each thought, verify assumptions, identify root causes, iterate until the foundation is solid | **Study** — analyze results, test understanding |
| **Rhetoric** | Implementation — only after Grammar and Logic are done, produce the output (code, config, documentation) | **Do** / **Act** — execute with understanding, apply learnings |

#### 2.3 Why This Matters for the Mindmap

This explains why going deep into "rabbit holes" is productive, not wasteful: you're doing Grammar and Logic properly before Rhetoric. The mindmap ensures you can always find your way back because the structure is visible — every thought is a node, every exploration is a sub-tree.

It also explains why premature implementation fails: jumping to Rhetoric (building) without completing Grammar (what are we building?) and Logic (does this design hold up?) produces work that needs to be redone.

The mindmap IS the Grammar phase made visible. PDSA cycles are the Logic phase made systematic. Development is the Rhetoric phase — and it only happens when the thinking is solid.

### 3. The Mindspace Structure: What's Inside the Mindmap

The mindmap's top-level nodes represent the internal structure of xpollination-mindspace itself — the categories of thought needed to build this tool:

```
xpollination-mindspace (root)
├── Requirements                — Questions to think through before building
│   ├── What is a "thought" in the mindmap?
│   ├── How do nodes relate to each other?
│   ├── What does Definition of Ready mean for a node?
│   ├── What does Definition of Done mean for a node?
│   ├── How does the Trivium apply to each node's lifecycle?
│   └── ... (explored via PDSA cycles — go deeper until sufficient)
├── Features                    — What the tool does
│   ├── Graph traversal (navigate the full tree)
│   ├── Drag-and-drop (rearrange thoughts between branches)
│   ├── Dual-link pattern (git URL + local path)
│   ├── PDSA integration (every node can be a PDSA cycle)
│   ├── Agent assignment and color-coding
│   └── ... (each feature gets its own PDSA when ready to build)
└── Infrastructure              — How it's built
    ├── Tech stack (Hugo, Alpine.js, SortableJS, Tailwind)
    ├── Data model (YAML node schema)
    ├── Deployment (Hetzner, nginx)
    └── Migration from xpollination-mcp-server
```

**The process:** Each requirement node gets explored. When you define something clearly enough, you add a PDSA in the right context and link it. You go deeper until it's sufficient to start development. At any point you have enough context and can find your way back out — because the mindmap shows the full structure.

This is Grammar → Logic → Rhetoric in practice:
1. **Requirements** = Grammar (gather the questions)
2. **PDSA cycles within requirements** = Logic (answer the questions, verify the answers)
3. **Features + Infrastructure** = Rhetoric (build, only when the thinking is solid)

### 4. The Node Model: Intrinsic Properties

Building on v3's recursive node and the refinement research (RCAA + I/O contracts), every node in the mindmap carries its own identity. The node knows what it needs, what it produces, and when it's done. This is Thomas's "object-oriented" requirement: the task itself knows its entry and exit criteria.

#### 4.1 Unified Node Schema

```yaml
node:
  id: string                    # Unique identifier
  title: string                 # Human-readable name of the thought
  owner: string                 # Who owns this thought: thomas | orchestrator | pdsa-agent | dev-agent
  type: string                  # task | quality-gate | decision | scope-break | milestone | pdsa-cycle

  # --- Intrinsic: Definition of Ready (DoR) ---
  # "What must be true before this node is workable?"
  definition_of_ready:
    context: string|null        # What the agent needs to know (from RCAA)
    inputs:                     # Explicit upstream dependencies with artifacts
      - from: string            # Source node ID
        type: string            # file | state | analysis
        description: string
        path: string|null       # File path (if type=file)
    status: string              # not_ready | ready
    # A node is "ready" when all inputs are available and context is clear.

  # --- Intrinsic: Definition of Done (DoD) ---
  # "What must be true for this node to be complete?"
  definition_of_done:
    action: string|null         # What to do — imperative instruction (from RCAA)
    acceptance: string|null     # Verifiable completion criteria (from RCAA)
    quality_gates:              # Structured verification checkpoints
      - name: string
        status: string          # pending | pass | fail
        verifier: string        # Agent ID or "thomas"
    outputs:                    # What this node produces for downstream
      - type: string            # file | state | analysis
        description: string
        path: string|null
    status: string              # not_done | done
    # A node is "done" when all quality gates pass and all outputs exist.

  # --- State ---
  status: string                # pending | active | paused | complete | failed | blocked
  pdsa_phase: string|null       # plan | do | study | act | complete | null
  pdsa_ref:                     # Reference to PDSA document (dual-link)
    git_url: string|null        # Human-readable: GitHub URL
    local_path: string|null     # Agent-readable: filesystem path

  # --- Structure ---
  dependencies: [string]        # Node IDs that must complete first (blocking)
  children: [node]              # Recursive: sub-thoughts at any depth
```

#### 4.2 The Self-Aware Node: Why DoR and DoD Are Intrinsic

##### Thomas's Vision (Verbatim — Iteration 2, 2026-02-02)

> "Let us zoom in to ensure you understand my thought: let us compare to an already solved real-life application. IP packages, or better to grasp let's also discuss logistics. When a warehouse is constructed, on the software side the stations are defined based on their capabilities and processes there. The package (containers...) know their process and book themselves into the varieties of options — like getting wrapped, made ready for shipping, the containers book themselves the next flight and truck and so on. The infrastructure just optimizes the current flow, the logic itself comes from the 'self-aware' container. And the same thought I am applying into this point. I want to think object oriented. The process is defined in the object and it knows what needs to be tested. So the tests need to be created. The object knows that and books itself into the service station where the infrastructure is creating the test case. Based on its location within the mindspace, the station receives all needed context and can fulfill its task. That can be automatically done through AI or human developers. We are at the moment only focusing on the object itself."

##### The Logistics Analogy

In a modern warehouse, there are two distinct layers:

1. **Stations (Infrastructure):** Wrapping stations, labeling stations, loading docks, shipping lanes. Each station has capabilities — it can wrap, label, scan, load. The station doesn't decide what happens to a container. It provides a service.

2. **Containers (Self-Aware Objects):** A container knows its own process. It knows: "I need to be wrapped, then labeled, then loaded onto flight LH-442, then onto truck T-7 to Munich." The container *books itself* into the stations it needs. The wrapping station doesn't decide which containers to wrap — the container arrives and says "wrap me, here are my dimensions and fragility requirements."

The infrastructure (stations) optimizes throughput — scheduling, parallel processing, load balancing. But the **logic of what needs to happen** lives in the container, not in the infrastructure.

##### The IP Packet Analogy

An IP packet carries its own destination address, protocol, TTL, and flags. The network (routers, switches) routes the packet, but it doesn't decide where the packet goes. The packet itself declares: "I'm going to 10.33.33.2, I'm TCP, I need reliable delivery." The network provides the service; the packet defines the need.

##### Applied to the Mindmap Node

The mindmap node IS the self-aware container. It is not a passive record that infrastructure acts upon — it is an active object that knows its own lifecycle:

| Container (Logistics) | IP Packet | Mindmap Node |
|----------------------|-----------|--------------|
| Knows its process (wrap → label → ship) | Knows its destination and protocol | Knows its DoR and DoD (what inputs it needs, what tests must pass, what outputs it produces) |
| Books itself into stations | Routes itself through the network | Books itself into service stations (test creation, code review, deployment) |
| Carries its own requirements (fragility, dimensions) | Carries its own headers (TTL, flags) | Carries its own context (RCAA: role, context, action, acceptance) |
| Station receives the container and fulfills its service | Router receives the packet and forwards it | Station (AI agent or human) receives the node's context and fulfills its task |

**The critical distinction:**

- **The node (object):** Defines WHAT needs to happen. Knows its own process. Carries its own entry criteria (DoR), exit criteria (DoD), and test requirements. This is what we are defining now.
- **The infrastructure (stations):** Provides HOW things get done. Creates test cases, runs builds, deploys code, reviews quality. Receives context from the node's position in the mindspace graph. This comes later.

##### What the Node Knows About Itself

A self-aware mindmap node carries:

1. **Its process** — What steps does this thought need to go through? (captured in `pdsa_phase`: plan → do → study → act)
2. **Its readiness requirements** — What must exist before work can begin? (captured in `definition_of_ready`: context, inputs)
3. **Its completion requirements** — What must be true when done? (captured in `definition_of_done`: acceptance criteria, quality gates, outputs)
4. **Its test requirements** — What needs to be tested? The node declares this; the testing station creates and runs the tests. (captured in `definition_of_done.quality_gates` — the node says "test X must pass," the infrastructure figures out how to test it)
5. **Its context** — Based on its location in the mindspace tree, any service station that processes this node receives the full path context (parent nodes, sibling nodes, the scope stack)

##### Why This Matters: Object vs. Infrastructure

In traditional PM, the process is external: a Jira workflow defines states, a CI pipeline defines tests, a team lead defines "done." The task is passive data that flows through external processes.

In mindspace, the process is intrinsic: the node defines its own states, declares its own test requirements, knows its own "done." The infrastructure (agents, tooling, dashboard) serves the node — it doesn't define it.

This is the same inversion that made logistics and networking scalable: push intelligence into the object, keep infrastructure generic and service-oriented.

**Current scope:** We are defining the object (the node schema, DoR, DoD, self-awareness). The infrastructure (service stations, automation, agent dispatch) is a future concern. The object must be right first — everything else builds on it.

#### 4.3 Status Derivation

Leaf nodes are set manually. Non-leaf nodes derive status from children:

```
complete  : ALL children complete AND definition_of_done.status = done
active    : at least one child is active
paused    : was active, now suspended
blocked   : definition_of_ready.status = not_ready (inputs missing)
failed    : any quality gate has status "fail"
pending   : not yet started
```

### 5. The Dual-Link Pattern

Thomas requires that every cross-repo reference has two forms:
- **Human-readable**: GitHub URL (for people with browser access)
- **Agent-readable**: Local filesystem path (for agents running on the server)

This applies to:
- `pdsa_ref` on any node
- Cross-repo navigation (from mindspace node to the actual repo)
- Any file reference in inputs/outputs

#### 5.1 Dual-Link Schema

```yaml
# On any reference field:
pdsa_ref:
  git_url: "https://github.com/PichlerThomas/HomeAssistant/blob/main/systems/hetzner-cx22-ubuntu/pdca/claude-code-setup/2026-02-02-UTC-1100.claude-session-launcher-fix.pdsa.md"
  local_path: "/home/developer/workspaces/github/PichlerThomas/HomeAssistant/systems/hetzner-cx22-ubuntu/pdca/claude-code-setup/2026-02-02-UTC-1100.claude-session-launcher-fix.pdsa.md"
```

#### 5.2 Cross-Repo References

When a mindspace node references content in another repo (e.g., infrastructure docs in HomeAssistant, code in xpollination-mcp-server), the dual-link ensures both humans and agents can navigate:

```yaml
# Example: a mindspace node linking to infrastructure documentation
node:
  id: "infra-hetzner-setup"
  title: "Hetzner CX22 Server Setup"
  definition_of_ready:
    inputs:
      - from: "homeassistant-repo"
        type: "file"
        description: "Server credentials and access docs"
        path:
          git_url: "https://github.com/PichlerThomas/HomeAssistant/blob/main/systems/hetzner-cx22-ubuntu/credentials.md"
          local_path: "/home/developer/workspaces/github/PichlerThomas/HomeAssistant/systems/hetzner-cx22-ubuntu/credentials.md"
```

### 6. Graph Traversal and Node Rearrangement

Thomas requires:
- **Traverse the whole graph back and forth** — navigate from any node to any other node
- **Drag-and-drop nodes between branches** — when thinking shifts, move a thought to where it belongs now

#### 6.1 Traversal

The mindmap is a tree (not a DAG). Navigation:
- **Down**: expand children to go deeper into a thought
- **Up**: collapse to parent to zoom out
- **Scope stack**: the path from root to the currently focused node — clickable breadcrumb
- **Cross-reference**: follow `pdsa_ref` or `inputs[].from` links to jump to related nodes

The dashboard renders the tree with expand/collapse (from v3 design: flattened tree with depth-based indentation). The scope stack breadcrumb enables quick jumps to any ancestor.

#### 6.2 Node Rearrangement (Drag-and-Drop)

When a thought no longer belongs under its current parent:
1. Drag the node from its current position
2. Drop it under a different parent (same depth or different depth)
3. The node keeps its children, DoR, DoD, and all intrinsic properties
4. References to this node (via `dependencies` or `inputs[].from`) remain valid because they use the node's `id`, not its position

Technical: SortableJS (already in v2/v3 stack) supports nested sortable lists. Moving a node between parents is a remove-from-old + insert-into-new operation on the YAML tree.

**Why this matters**: Thomas's thinking evolves. A task that started as infrastructure might become a mindspace concern. A content pipeline idea might spawn a new top-level project. The mindmap must be as fluid as the thinking.

### 7. Root Cause Analysis Alignment

Thomas values the root-cause approach. In the mindmap, root cause analysis maps naturally:

- A **problem** is a node (type: `task` or `decision`)
- **Investigation** creates children — each possible cause is a child node
- **Evidence** is captured in each child's `outputs[]`
- The **root cause** is the child node that gets status `complete` with quality gates passing
- **Fix** is a sibling or child of the root cause node
- The whole investigation is visible as a sub-tree in the mindmap

This replaces ad-hoc debugging with structured decomposition, visible in the same tree as everything else.

### 8. Agent Registry

Unchanged from v3. Agents are defined once, referenced by ID:

```yaml
meta:
  agents:
    thomas:
      display: "Thomas"
      color: "amber"
      role: "Strategic direction, approval, Definition of Done verifier"
    orchestrator:
      display: "Orchestrator"
      color: "indigo"
      role: "Coordination, relay, quality gates, focus enforcement"
    pdsa-agent:
      display: "PDSA"
      color: "violet"
      role: "Planning, research, PDSA documentation, quality review"
    dev-agent:
      display: "Dev"
      color: "emerald"
      role: "Implementation, git commits, operational execution"
```

### 9. Evolution from v1 to Mindspace

| Version | Model | Key Insight |
|---------|-------|-------------|
| v1 | Flat YAML: phases → items → sub_items | Hierarchical view matches mental model |
| v2 | Added PDSA phase indicators, scope breaks, quality gates | The process itself needs visualization |
| v3 | Recursive tree: one node type, unbounded depth, agent assignments | Depth emerges from work complexity, not fixed structure |
| Refinement | RCAA pattern, input/output contracts, single-repo PDSAs | Tasks must be self-contained and chainable |
| **Mindspace** | **Mindmap: thoughts with intrinsic DoR/DoD, dual-links, graph traversal** | **The tool IS the shared mental model, not just a tracker** |

Each version added a dimension. Mindspace synthesizes all of them.

### 10. Migration Plan

#### 10.1 PDSA Document Migration

Move PM-tool-related PDSAs from `xpollination-mcp-server/docs/pdca/` to `xpollination-mindspace/docs/pdsa/`:

| Source (xpollination-mcp-server) | Target (xpollination-mindspace) |
|----------------------------------|--------------------------------|
| `2026-01-29-UTC-1445.projectmanagement-tool.pdca.md` | `docs/pdsa/2026-01-29-UTC-1445.projectmanagement-tool.pdca.md` |
| `2026-01-30-UTC-1100.pm-tool-v2-implementation.pdsa.md` | `docs/pdsa/2026-01-30-UTC-1100.pm-tool-v2-implementation.pdsa.md` |
| `2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` | `docs/pdsa/2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` |
| `2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` | `docs/pdsa/2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` |

Also migrate:
- `docs/dashboard/currentContext.yaml` → context data for the mindspace dashboard
- `docs/dashboard/layouts-backup/` → dashboard layout backups

Delete originals from xpollination-mcp-server after copy. Update any cross-references.

#### 10.2 Data Model Migration (v2 YAML → Mindspace YAML)

The existing `currentContext.yaml` uses v2 structure (phases → items → sub_items). Migration:

1. Each `phase` becomes a node at depth 0 under its project root
2. Each `item` becomes a child node at depth 1
3. Each `sub_item` becomes a child node at depth 2
4. `quality_gates` move into `definition_of_done.quality_gates`
5. `pdsa_ref` becomes a dual-link object
6. Free-text `description` fields with RCAA pattern get split into `definition_of_ready.context` + `definition_of_done.action` + `definition_of_done.acceptance`

This is mechanical — no data loss.

### 11. What Mindspace Is NOT

To prevent scope creep:

- **Not a Jira clone.** No sprints, no story points, no velocity charts. PDSA replaces sprints.
- **Not a knowledge base.** Documentation lives in repos. The mindmap links to it — it doesn't duplicate it.
- **Not an agent runtime.** Agents read the mindmap for context, but execution happens in tmux/Claude Code. The mindmap is the map, not the territory.
- **Not a real-time collaboration tool.** One agent writes YAML, Hugo renders it, others read. No websockets, no conflict resolution (yet).

### 12. Quality Gates for This PDSA

| Gate | Criteria | Verifier |
|------|----------|----------|
| QG-1 | Node schema includes intrinsic DoR and DoD as fields on the node | pdsa-agent |
| QG-2 | Dual-link pattern documented with concrete examples | pdsa-agent |
| QG-3 | Graph traversal and drag-and-drop requirements documented | pdsa-agent |
| QG-4 | Migration plan covers all existing PDSAs and dashboard data | pdsa-agent |
| QG-5 | Vision aligns v3 recursive tree with Thomas's mindmap metaphor | pdsa-agent |
| QG-6 | Trivium Method documented as foundational thinking framework, connected to PDSA | pdsa-agent |
| QG-7 | Mindspace internal structure (features, infrastructure, requirements) replaces workspace mapping | pdsa-agent |
| QG-8 | Thomas approves vision as matching his intent | thomas |

**Self-assessment (QG-1 through QG-7):**
- QG-1: PASS — Section 4.1 defines `definition_of_ready` and `definition_of_done` as intrinsic node fields
- QG-2: PASS — Section 5 defines dual-link schema with concrete YAML examples
- QG-3: PASS — Section 6 documents traversal (scope stack, expand/collapse) and drag-and-drop (SortableJS)
- QG-4: PASS — Section 10 lists all files to migrate with source/target paths
- QG-5: PASS — Section 1 maps every PM concept to a mindmap concept; Section 9 traces the evolution
- QG-6: PASS — Section 2 documents Grammar→Logic→Rhetoric with explicit mapping to mindmap activities and PDSA phases
- QG-7: PASS — Section 3 defines Requirements/Features/Infrastructure as internal mindspace structure

**QG-8: Pending Thomas review.**

---

## DO

*Dev agent to execute Step 3 (PDSA migration) after Thomas approves this vision.*

---

## STUDY

*Pending implementation and Thomas review.*

---

## ACT

*Pending.*

---

## REFERENCES

### Prior PDSAs (Evolution Chain)

| Document | What It Established |
|----------|-------------------|
| `2026-01-29-UTC-1445.projectmanagement-tool.pdca.md` | v1: flat YAML dashboard, Hugo + Alpine.js + SortableJS stack |
| `2026-01-30-UTC-1030.recursive-pdca-framework.pdca.md` | Recursive PDSA theory: Deming, Hoshin Kanri, fractal PM |
| `2026-01-30-UTC-1100.pm-tool-v2-implementation.pdsa.md` | v2: PDSA phase indicators, scope breaks, quality gates |
| `2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` | v3: one node type, unbounded depth, agent registry, scope stack |
| `2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` | RCAA pattern, input/output contracts, single-repo PDSAs |

### Source Locations (Dual-Links)

| Document | Git URL | Local Path |
|----------|---------|------------|
| This PDSA | `https://github.com/PichlerThomas/xpollination-mindspace/blob/main/docs/pdsa/2026-02-02-UTC-1300.mindspace-vision.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mindspace/docs/pdsa/2026-02-02-UTC-1300.mindspace-vision.pdsa.md` |
| v3 Design | `https://github.com/PichlerThomas/xpollination-mcp-server/blob/main/docs/pdca/2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mcp-server/docs/pdca/2026-02-01-UTC-1400.pm-tool-v3-recursive-tree.pdsa.md` |
| Refinement | `https://github.com/PichlerThomas/xpollination-mcp-server/blob/main/docs/pdca/2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` | `/home/developer/workspaces/github/PichlerThomas/xpollination-mcp-server/docs/pdca/2026-02-01-UTC-1600.pm-tool-refinement-research.pdsa.md` |
